#!/usr/bin/perl -w
# Автор: Юрий Решетников <reshu@mail.ru>
use strict;
use warnings;
use utf8;
use Reshu::Utils;

my($new_script,$old);
while(@ARGV) {
    my $key = shift @ARGV;
    if($key eq '--new' || $key eq '-n') {
	die eval dw qw($new_script $old $key \@ARGV) unless @ARGV && !defined $new_script;
	$new_script = shift @ARGV;
    }
    elsif($key eq '--old' || $key eq '-o') {
	die eval dw qw($new_script $old $key \@ARGV) unless @ARGV && !defined $old;
	$old->{script} = shift @ARGV;
    }
    elsif($key eq '--db') {
	die eval dw qw($new_script $old $key \@ARGV) unless @ARGV && !exists($old->{script}) && !exists($old->{db});
	$old->{db} = shift @ARGV;
    }
    elsif($key eq '--defaults-file') {
	die eval dw qw($new_script $old $key \@ARGV) unless @ARGV && !exists($old->{script}) && !exists($old->{defaults_file});
	$old->{defaults_file} = shift @ARGV;
    }
    elsif($key eq '--host' || $key eq '-h') {
	die eval dw qw($new_script $old $key \@ARGV) unless @ARGV && !exists($old->{script}) && !exists($old->{host});
	$old->{host} = shift @ARGV;
    }
    elsif($key eq '--user' || $key eq '-u') {
	die eval dw qw($new_script $old $key \@ARGV) unless @ARGV && !exists($old->{script}) && !exists($old->{user});
	$old->{user} = shift @ARGV;
    }
    elsif($key eq '--password' || $key eq '-p') {
	die eval dw qw($new_script $old $key \@ARGV)
	    unless !exists($old->{script}) && !exists($old->{password}) && !exists($old->{read_password});
	$old->{read_password} = 1;
    }
    elsif($key =~ s/\A-p// || $key =~ s/\A--password=//) {
	die eval dw qw($new_script $old $key \@ARGV)
	    unless !exists($old->{script}) && !exists($old->{password}) && !exists($old->{read_password});
	$old->{password} = $key;
    }
    else { die eval dw qw($new_script $old $key \@ARGV); }
}
die eval dw qw($new_script $old) unless $new_script && $old && ($old->{script} || $old->{db});

# warn eval dw qw($new_script $old);

my $new_struct = &read_script($new_script);
my $old_struct;
if($old->{script}) { $old_struct = &read_script($old->{script}); }
else { die '+++ ', eval dw qw($old); }

sub read_script {
    my $script = shift;
    my $db;
    xopen my($in), '<', $script;
    while(defined(my $line = <$in>)) {
	if($line =~ /\A\s*--/) {}
	elsif($line =~ /\A\s*\z/) {}
	elsif($line =~ /\A\s*create\s+database\s+.*;\s*\z/i) {}
	elsif($line =~ /\A\s*use\s+.*;\s*\z/i) {}
	elsif($line =~ /\A\s*drop\s+table\s+.*;\s*\z/i) {}
	elsif($line =~ /\A\s*create\s+table\s+(`.*`)\s*\(\s*\z/i) {
	    my $table_qname = $1;
	    die eval dw qw($table_qname $db->{$table_qname}) if $db->{$table_qname};
	    my $sql = $line;
	    while(1) {
		die eval dw qw($sql) unless defined($line = <$in>);
		$sql .= $line;
		last if $line =~ /\A\s*\).*;\s*\z/;
	    }
	    $db->{$table_qname} = &read_mysql_struct($sql);
	}
	elsif($line =~ /\A\s*alter\s+table\s+(`.*`)\s*\z/i) {
	    # mysqldump такого не генерирует, но в моих данных это будет
	    my $table_qname = $1;
	    die eval dw qw($table_qname) unless (my $table = $db->{$table_qname})
		&& defined($line = <$in>)
		&& $line =~ /\A\s*add\s+foreign\s+key\s*.*;\s*\z/i;
	    # +++
	}
	elsif($line =~ /\A\s*delimiter\s+;;+\s*\z/i) {
	    my $sql;
	    while(1) {
		die eval dw qw($sql) unless defined($line = <$in>);
		last if $line =~ /\A\s*delimiter\s+;\s*\z/i;
		$sql .= $line;
	    }
	    &read_mysql_trigger($sql);
	}
	elsif($line =~ /\A\s*\/\*!.*\*\/\s*;\s*\z/) {}
	else { die eval dw qw($line); }
    }
    xclose $in;
    return $db;
}

my $low_table_names;
my %type_map = (
    'int(11)' => 'integer',
    'bigint(20)' => 'bigint',
    'int(10) unsigned' => 'integer unsigned',
    'bigint(20) unsigned' => 'bigint unsigned',
    # 'tinyint(4)' => 'tinyint',
);

sub read_mysql_struct {
    my $ct = shift;
    my $table = {};
    die eval dw qw($table_name $ct) unless $ct =~ /\ACREATE TABLE `.*` \(\n/gci;
    my $xn = qr/\`[^,\\\`]+\`/;
    my $xnp = qr/\`([^,\\\`]+)\`/;
    my $xk = qr/\(($xn(?:\s*,\s*$xn)*)\)/;
    my $prev_field_name;
read_mysql_struct_line:
    my $comma = 0;
    if($ct =~ /\G\s*\`([^\\\`]+)\`\s+(\w+(?:\([^\)]+\))?(?:\s+unsigned)?)(?:(\s+NOT\s+NULL)|\s+NULL)?(\s+AUTO_INCREMENT)?(?:\s+DEFAULT (?:NULL|(CURRENT_TIMESTAMP|b?'.*?')))?(?:\s+ON\s+UPDATE\s+(CURRENT_TIMESTAMP|'.*?'))?(?:\s+COMMENT\s+'.*')?(,?)\n/gci) {
	my $field = {};
	(@{$field}{qw(sql_name sql_type not_null auto_increment default on_update)}, $comma) = ($1,$2,$3,$4,$5,$6,$7);
	if(my $t = $type_map{$field->{sql_type}}) { $field->{sql_type} = $t; }
	push @{$table->{field_sequence}}, $field;
	$table->{fields}{$field->{sql_name}} = $field;
	$field->{prev_field_name} = $prev_field_name;
	$prev_field_name = $field->{sql_name};
    }
    elsif($ct =~ /\G\s*PRIMARY\s+KEY\s*\((\`[^,\\\`]+\`(?:\s*,\s*\`[^,\\\`]+\`)*)\)(,?)\n/gci) {
	(my($list),$comma) = ($1,$2);
	$table->{primary_key} = [ &split_key_fields($list) ];
    }
    elsif($ct =~ /\G\s*(UNIQUE\s+)?KEY(?:\s+(\`[^\\\`]+\`))?\s*\((\`[^,\\\`]+\`(?:\s*,\s*\`[^,\\\`]+\`)*)\)(,?)\n/gci) {
	(my($unique,$qname,$list),$comma) = ($1,$2,$3,$4);
	push @{$table->{$unique ? 'unique_keys' : 'keys'}}, { qname => $qname, fields => [ &split_key_fields($list) ] };
    }
    elsif($ct =~ /\G\s*CONSTRAINT\s+($xn)\s+FOREIGN\s+KEY\s+$xk\s+REFERENCES\s+$xnp\s+$xk(?:\s+ON\s+DELETE\s+(CASCADE|NO\s+ACTION|SET\s+NULL))?(?:\s+ON\s+UPDATE\s+(CASCADE|NO\s+ACTION|SET\s+NULL))?(,?)\n/gci) {
	(my($name,$list,$ref_table,$ref_list,$on_delete,$on_update),$comma) = ($1,$2,$3,$4,$5,$6,$7);
	my @list = &split_key_fields($list);
	my @ref_list = &split_key_fields($ref_list);
	die if @list != 1; #+++
	die if @list != @ref_list;
	die unless $table->{fields}{$list[0]};
	# die eval dw qw($list[0] $table->{fields}{$list[0]}{ref} $table $ct) if $table->{fields}{$list[0]}{ref};
	die eval dw qw($table_name \@list $table->{fields}{$list[0]}) if $table->{fields}{$list[0]}{ref};
	if(my $high = hv $low_table_names, $ref_table) { $ref_table = $high; }
	$table->{fields}{$list[0]}{ref} = { sql_table => $ref_table, id => $ref_list[0], constraint => $name,
	    (defined($on_delete) ? (on_delete => lc($on_delete)) : ()),
	    (defined($on_update) ? (on_update => lc($on_update)) : ()) };
    }
    else { die eval &dw('pos($ct)', 'length($ct)', 'substr($ct, pos($ct), 20)', '$ct'); }
    goto read_mysql_struct_line if $comma;
    die eval dw('pos($ct)', 'length($ct)', 'substr($ct, pos($ct), 20)', '$ct')
	unless $ct =~ /\G\) ENGINE=\w+(?: AUTO_INCREMENT=\d+)? (?:DEFAULT CHARSET|CHARACTER SET)=\w+(?: COMMENT='.*')?\s*(?:;\s*)?\z/gci;
    #+++ Обработать Engine и Charset
    return $table;
}

sub split_key_fields { map substr($_, 1, length($_) - 2), split /\s*,\s*/, shift; }

sub read_mysql_trigger {
    my $ct = shift;
}
